#!/usr/bin/env python3

"""
tinc sync: admin
----------------

"""

import argparse, os, sys, json, pathlib, shutil, traceback, ipaddress, subprocess

parser = argparse.ArgumentParser()
parser.add_argument('config', help='network to administer', type=argparse.FileType('r'))
args = parser.parse_args()

try:
    cfg_json = json.loads(args.config.read())
except Exception as e:
    print('ERROR: Failed to read and parse config file:')
    print(e)
    sys.exit(1)


class NodeConfig:
    def __init__(self, node_name, node_json, node_addr, vpn_subnet):
        assert type(node_name) is str, 'INTERNAL ERROR (Json dict keys can only be strings?)'
        assert type(node_json) is dict, 'Node definition for "%s" expected to be a dictionary' % node_name

        self.name = node_name

        assert 'os' in node_json, 'Node "%s": expected key "os" not found in node definition' % node_name
        assert type(node_json['os']) is str, 'Node "%s": key "os" expected to be of type str' % node_name
        assert node_json['os'] in ['linux', 'darwin'], 'Node "%s": key "os" expected to have values in [linux, darwin]' % node_name
        self.os = node_json['os']

        assert 'tinc_cfg_root' in node_json, 'Node "%s": expected key "tinc_cfg_root" not found in node definition' % node_name
        assert type(node_json['tinc_cfg_root']) is str, 'Node "%s": key "tinc_cfg_root" expected to be of type str' % node_name
        assert node_json['tinc_cfg_root'][0] == '/', 'Node "%s": "tinc_cfg_root" "%s" expected to be an absolute path' % (node_name, node_json['tinc_cfg_root'])
        self.tinc_cfg_root = node_json['tinc_cfg_root']

        self.auto_update = False
        if 'auto_update' in node_json:
            assert type(node_json['auto_update'] is bool), 'Node "%s": key "auto_update" expected to be of type bool' % node_name
            self.auto_update = node_json['auto_update']

        self.connect_to = []
        if 'connect_to' in node_json:
            assert type(node_json['connect_to'] is list), 'Node "%s": key "connect_to" expected to be of type list' % node_name
            self.connect_to = node_json['connect_to']

        self.public_ips = []
        if 'public_ips' in node_json:
            assert type(node_json['public_ips'] is list), 'Node "%s": key "public_ips" expected to be of type list' % node_name
            try:
                self.public_ips = [ipaddress.ip_address(x) for x in node_json['public_ips']]
            except ValueError as e:
                print('For node "%s" key "public_ips":' % node_name, e)
                sys.exit(1)

        self.local_discovery = False
        if 'local_discovery' in node_json:
            assert type(node_json['local_discovery'] is bool), 'Node "%s": key "local_discovery" expected to be of type bool' % node_name
            self.local_discovery = node_json['local_discovery']

        self.bind_to_interface = None
        if 'bind_to_interface' in node_json:
            assert type(node_json['bind_to_interface']) is str, 'Node "%s": key "bind_to_interface" expected to be of type str' % node_name
            self.bind_to_interface = node_json['bind_to_interface']

        self.vpn_provides_subnets_to_node = []
        if 'vpn_provides_subnets_to_node' in node_json:
            assert type(node_json['vpn_provides_subnets_to_node']) is list, 'Node "%s": key "vpn_provides_subnets_to_node" expected to be of type list' % node_name
            try:
                self.vpn_provides_subnets_to_node = [ipaddress.ip_network(x) for x in node_json['vpn_provides_subnets_to_node']]
            except ValueError as e:
                print('For node "%s" key "vpn_provides_subnets_to_node":' % node_name, e)
                sys.exit(1)

        self.node_provides_subnets_to_vpn = []
        if 'node_provides_subnets_to_vpn' in node_json:
            assert type(node_json['node_provides_subnets_to_vpn']) is list, 'Node "%s": key "node_provides_subnets_to_vpn" expected to be of type list' % node_name
            self.node_provides_subnets_to_vpn = { x.split(':')[0]: ipaddress.ip_network(x.split(':')[1]) for x in node_json['node_provides_subnets_to_vpn'] }

        self.resolve_hosts_locally = False
        if 'resolve_hosts_locally' in node_json:
            assert type(node_json['resolve_hosts_locally']) is bool, 'Node "%s": key "resolve_hosts_locally" expected to be of type bool' % node_name
            self.resolve_hosts_locally = node_json['resolve_hosts_locally']

        self.ip_address = ipaddress.ip_network(vpn_subnet.exploded)
        self.ip_address.network_address = node_addr


class AdminConfig:
    def __init__(self, cfg_json):
        assert 'network_name' in cfg_json, 'expected key "network_name" not found in config'
        assert type(cfg_json['network_name']) is str, 'Key "network_name" expected to be of type str'
        self.network_name = cfg_json['network_name']

        assert 'public_keys_path' in cfg_json, 'expected key "public_keys_path" not found in config'
        assert type(cfg_json['public_keys_path']) is str, 'Key "public_keys_path" expected to be of type str'
        assert cfg_json['public_keys_path'][0] == '/', '"public_keys_path" "%s" expected to be an absolute path' % cfg_json['public_keys_path']
        assert os.path.isdir(cfg_json['public_keys_path']), '"public_keys_path" "%s" does not exist or is not a directory' % cfg_json['public_keys_path']
        self.public_keys_path = cfg_json['public_keys_path']

        assert 'output_path' in cfg_json, 'expected key "output_path" not found in config'
        assert type(cfg_json['output_path']) is str, 'Key "output_path" expected to be of type str'
        assert cfg_json['output_path'][0] == '/', '"output_path" "%s" expected to be an absolute path' % cfg_json['output_path']
        assert os.path.isdir(cfg_json['output_path']), '"output_path" "%s" does not exist or is not a directory' % cfg_json['output_path']
        self.output_path = cfg_json['output_path']
        if self.output_path[-1] == '/':
            self.output_path = self.output_path[:-1]

        assert 'admin_node' in cfg_json, 'expected key "admin_node" not found in config'
        assert type(cfg_json['admin_node']) is str, 'Key "admin_node" expected to be of type str'
        self.admin_node = cfg_json['admin_node']

        assert 'vpn_subnet' in cfg_json, 'expected key "vpn_subnet" not found in config'
        assert type(cfg_json['vpn_subnet']) is str, 'Key "vpn_subnet" expected to be of type str'
        try:
            self.vpn_subnet = ipaddress.ip_network(cfg_json['vpn_subnet'])
            self.vpn_hosts = list(ipaddress.ip_network(self.vpn_subnet).hosts())
        except ValueError as e:
            print('Could not parse "vpn_subnet":', e)
            sys.exit(1)

        self.compression = None
        if 'compression' in cfg_json:
            assert type(cfg_json['compression']) is str, 'Key "compression" expected to be of type str'
            compression_map = {
                'off': 0,
                'zlib_fast': 1,
                'zlib_best': 9,
                'lzo_fast': 10,
                'lzo_best': 11
            }
            assert cfg_json['compression'] in compression_map.keys(), 'Did not understand "compression" value "%s". Valid values are %s' % (cfg_json['compression'], list(compression_map.keys()))
            self.compression = compression_map[cfg_json['compression']]

        assert 'nodes' in cfg_json, 'expected key "nodes" not found in config'
        assert type(cfg_json['nodes']) is dict, 'Key "nodes" expected to be a dictionary'
        self.nodes = { n: NodeConfig(n, j, h, self.vpn_subnet) for (n,j), h in zip(cfg_json['nodes'].items(), self.vpn_hosts) }

        assert self.admin_node in self.nodes, 'Admin node "%s" not found in "nodes"' % self.admin_node

        for node_name, node_cfg in self.nodes.items():
            for connect_to_name in node_cfg.connect_to:
                assert connect_to_name in self.nodes, 'Node "%s": Key "connect_to": Item "%s" not found in "nodes"' % (node_name, connect_to_name)


admin_up_script_format = \
"""#!/bin/bash

set -euxo pipefail

function_update() {{
    sleep 1
    echo "$(date) {cfg_network_name}: ""Starting admin-up script" >> /tmp/tinc-sync.log

    echo "$(date) {cfg_network_name}: ""Updating DNS entries" >> /tmp/tinc-sync.log
    if [ -f /etc/hosts ]; then
        sed "/# Added by tinc-sync network={cfg_network_name}/d" -i /etc/hosts
    fi
    if [ -f {node_tinc_cfg_root}/{cfg_network_name}/dns_entries ]; then
        cat {node_tinc_cfg_root}/{cfg_network_name}/dns_entries >> /etc/hosts
    fi

    scp -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -i {node_tinc_cfg_root}/{cfg_network_name}/rsa_key.priv ubuntu@{cfg_admin_node_internal_ip_address}:{cfg_output_path}/{node_name}.tar.bz2 /tmp/{cfg_network_name}-{node_name}-new.tar.bz2
    if [ -f /tmp/{cfg_network_name}-{node_name}-old.tar.bz2 ]; then
        set +e
        cmp --silent /tmp/{cfg_network_name}-{node_name}-new.tar.bz2 /tmp/{cfg_network_name}-{node_name}-old.tar.bz2
        ret=$?
        set -e
        if [ $ret -eq 0 ]; then
            echo "$(date) {cfg_network_name}: ""Got identical bootstrap files. No need to update" >> /tmp/tinc-sync.log
            echo "$(date) {cfg_network_name}: ""Finished admin-up script" >> /tmp/tinc-sync.log
            exit 0
        fi
    fi
    echo "$(date) {cfg_network_name}: ""Updating configuration" >> /tmp/tinc-sync.log
    mv /tmp/{cfg_network_name}-{node_name}-new.tar.bz2 /tmp/{cfg_network_name}-{node_name}-old.tar.bz2
    ls {node_tinc_cfg_root}/{cfg_network_name}/ | grep -v "rsa_key.priv" | grep -v "rsa_key.pub" | xargs rm -fr
    tar -xf /tmp/{cfg_network_name}-{node_name}-old.tar.bz2 -C {node_tinc_cfg_root}/{cfg_network_name}

    echo "$(date) {cfg_network_name}: ""Finished admin-up script" >> /tmp/tinc-sync.log
    exit 0
}}

function_update &
"""


try:
    cfg = AdminConfig(cfg_json)

    shutil.rmtree(cfg.output_path)
    os.mkdir(cfg.output_path)
    os.mkdir('%s/hosts' % cfg.output_path)
    with open('%s/dns_entries' % cfg.output_path, 'a') as dns_entries:
        dns_entries.write('\n')

    ssh_authorized_keys_filename = os.path.expanduser('~/.ssh/authorized_keys')
    if os.path.isfile(ssh_authorized_keys_filename):
        with open(ssh_authorized_keys_filename, 'r') as ssh_authorized_keys_file:
            ssh_authorized_keys_lines = ssh_authorized_keys_file.readlines()
            ssh_authorized_keys_lines = [x for x in ssh_authorized_keys_lines if x.find('# Added by tinc-sync network=%s' % cfg.network_name) == -1]
        pathlib.Path(ssh_authorized_keys_filename).write_text(''.join(ssh_authorized_keys_lines))

    print('Generating configuration...')
    for node_name, node_cfg in cfg.nodes.items():
        node_path = '%s/%s' % (cfg.output_path, node_name)
        os.mkdir(node_path)

        # Writing tinc.conf
        with open('%s/tinc.conf' % node_path, 'w') as tinc_conf:
            tinc_conf.write('Name = %s\n' % node_name)

            if node_cfg.os == 'linux':
                device_type = 'tun'
            elif node_cfg.os == 'darwin':
                device_type = 'utun'
            else:
                assert False, 'Unknown OS "%s"' % node_cfg.os

            tinc_conf.write('DeviceType = %s\n' % device_type)

            tinc_conf.write('AddressFamily = ipv4\n')

            if node_cfg.bind_to_interface:
                tinc_conf.write('BindToInterface = %s\n' % node_cfg.bind_to_interface)

            for connect_to_name in node_cfg.connect_to:
                tinc_conf.write('ConnectTo = %s\n' % connect_to_name)

            if node_cfg.local_discovery:
                local_discovery = 'yes'
            else:
                local_discovery = 'no'
            tinc_conf.write('LocalDiscovery = %s\n' % local_discovery)

            if cfg.compression:
                tinc_conf.write('Compression = %s\n' % cfg.compression)

        # Writing tinc-up
        with open('%s/tinc-up' % node_path, 'w') as tinc_up:
            if node_cfg.os == 'linux':
                tinc_up.write('#!/bin/bash\n')
                tinc_up.write('ip link set $INTERFACE up\n')
                tinc_up.write('ip addr add %s/32 dev $INTERFACE\n' % node_cfg.ip_address.network_address.exploded)
                tinc_up.write('ip route add %s dev $INTERFACE\n' % cfg.vpn_subnet.exploded)
                tinc_up.write('if [ -f %s/%s/dns_entries ]; then cat %s/%s/dns_entries >> /etc/hosts; fi\n' % (node_cfg.tinc_cfg_root, cfg.network_name, node_cfg.tinc_cfg_root, cfg.network_name))

                if node_cfg.provide_internet_from_vpn:
                    tinc_up.write('ip route add default dev $INTERFACE\n')
                if node_cfg.provide_internet_to_vpn:
                    tinc_up.write('iptables -t nat -A POSTROUTING -o $%s -j MASQUERADE\n' % node_cfg.provide_internet_to_vpn)

            elif node_cfg.os == 'darwin':
                assert not node_cfg.provide_internet_from_vpn, 'Not implemented yet: "provide_internet_from_vpn" for os "%s"' % node_cfg.os
                assert not node_cfg.provide_internet_to_vpn, 'Not implemented yet: "provide_internet_to_vpn" for os "%s"' % node_cfg.os
                tinc_up.write('#!/bin/bash\n')
                tinc_up.write('ifconfig $INTERFACE inet %s %s up\n' % (node_cfg.ip_address.network_address.exploded, node_cfg.ip_address.netmask.exploded))
                tinc_up.write('route -n add -net %s %s\n' % (node_cfg.ip_address.supernet(0).exploded, node_cfg.ip_address.network_address.exploded))
                tinc_up.write('if [ -f %s/%s/dns_entries ]; then cat %s/%s/dns_entries >> /etc/hosts; fi\n' % (node_cfg.tinc_cfg_root, cfg.network_name, node_cfg.tinc_cfg_root, cfg.network_name))            

            else:
                assert False, 'Unknown OS "%s"' % node_cfg.os
        os.chmod('%s/tinc-up' % node_path, 0o755)

        # Writing tinc-down
        with open('%s/tinc-down' % node_path, 'w') as tinc_down:
            if node_cfg.os == 'linux':
                tinc_down.write('#!/bin/bash\n')
                if node_cfg.provide_internet_to_vpn:
                    tinc_down.write('iptables -t nat -D POSTROUTING -o %s -j MASQUERADE\n' % node_cfg.provide_internet_to_vpn)
                if node_cfg.provide_internet_from_vpn:
                    tinc_down.write('ip route del default dev $INTERFACE\n')
                tinc_down.write('ip route del %s dev $INTERFACE\n' % cfg.vpn_subnet.exploded)
                tinc_down.write('ip addr del %s/32 dev $INTERFACE\n' % node_cfg.ip_address.network_address.exploded)
                tinc_down.write('ip link set $INTERFACE down\n')
                tinc_down.write('if [ -f /etc/hosts ]; then sed "/# Added by tinc-sync network=%s/d" -i /etc/hosts; fi\n' % cfg.network_name)
            
            elif node_cfg.os == 'darwin':
                assert not node_cfg.provide_internet_from_vpn, 'Not implemented yet: "provide_internet_from_vpn" for os "%s"' % node_cfg.os
                assert not node_cfg.provide_internet_to_vpn, 'Not implemented yet: "provide_internet_to_vpn" for os "%s"' % node_cfg.os
                tinc_down.write('#!/bin/bash\n')
                tinc_down.write('route -n delete -net %s %s\n' % (node_cfg.ip_address.supernet(0).exploded, node_cfg.ip_address.network_address.exploded))
                tinc_down.write('ifconfig $INTERFACE down\n')
                tinc_down.write('if [ -f /etc/hosts ]; then sed "/# Added by tinc-sync network=%s/d" -i /etc/hosts; fi\n' % cfg.network_name)
            
            else:
                assert False, 'Unknown OS "%s"' % node_cfg.os
        os.chmod('%s/tinc-down' % node_path, 0o755)

        # Writing hosts files
        with open('%s/hosts/%s' % (cfg.output_path, node_name), 'w') as hosts_conf:
            for public_ip in node_cfg.public_ips:
                hosts_conf.write('Address = %s\n' % public_ip.exploded)

            hosts_conf.write('Subnet = %s\n' % node_cfg.ip_address.network_address.exploded)

            if node_cfg.provide_internet_to_vpn:
                hosts_conf.write('Subnet = 0.0.0.0/0\n')

            pub_key_name = '%s/%s.pub' % (cfg.public_keys_path, node_name)
            assert os.path.isfile(pub_key_name), 'Public key file "%s" not found' % pub_key_name
            pubkey = pathlib.Path(pub_key_name).read_text()
            hosts_conf.write(pubkey)
            hosts_conf.write('\n')

            # Write authorized keys
            if node_name != cfg.admin_node and node_cfg.auto_update:
                try:
                    command = ['ssh-keygen', '-f', pub_key_name, '-i -m pem']
                    retval = subprocess.run(' '.join(command), shell=True, check=True, stdout=subprocess.PIPE).stdout.decode('utf-8')
                    assert retval[-1] == '\n', 'INTERNAL ERROR: ssh key expected to end in newline'     # TODO Raise an exception instead of asserting
                except subprocess.CalledProcessError as e:
                    print('ERROR: Could not convert public key into ssh compatible format')
                    sys.exit(1)
                with open(ssh_authorized_keys_filename, 'a') as ssh_authorized_keys_file:
                    this_authorized_key = 'restrict %s # Added by tinc-sync network=%s node=%s\n' % (retval[:-1], cfg.network_name, node_name)
                    ssh_authorized_keys_file.write(this_authorized_key)

        # Writing admin-up
        if node_name != cfg.admin_node and node_cfg.auto_update:
            with open('%s/admin-up.tmp' % node_path, 'w') as admin_up:
                admin_up.write(admin_up_script_format.format(
                    cfg_network_name=cfg.network_name,
                    cfg_admin_node_internal_ip_address=cfg.nodes[cfg.admin_node].ip_address.network_address.exploded,
                    node_name=node_name,
                    cfg_output_path=cfg.output_path,
                    node_tinc_cfg_root=node_cfg.tinc_cfg_root))


        # Write the DNS entries
        with open('%s/dns_entries' % cfg.output_path, 'a') as dns_entries:
            dns_entries.write('%s %s.%s # Added by tinc-sync network=%s\n' % (node_cfg.ip_address.network_address.exploded, node_name, cfg.network_name, cfg.network_name))

    # Copy the hosts file to each node and tarzip it up
    for node_name, node_cfg in cfg.nodes.items():
        node_path = '%s/%s' % (cfg.output_path, node_name)

        if node_cfg.resolve_hosts_locally:
            shutil.copyfile('%s/dns_entries' % cfg.output_path, '%s/dns_entries' % node_path)

        shutil.copytree('%s/hosts' % cfg.output_path, '%s/hosts' % node_path)
        if node_name != cfg.admin_node and node_cfg.auto_update:
            os.chmod('%s/admin-up.tmp' % node_path, 0o755)
            os.rename('%s/admin-up.tmp' % node_path, '%s/hosts/%s-up' % (node_path, cfg.admin_node))

        try:
            command = ['tar', '-C', node_path, '-cjf', '%s/%s.tar.bz2' % (cfg.output_path, node_name), 'hosts', 'tinc.conf', 'tinc-up', 'tinc-down']
            if node_cfg.resolve_hosts_locally:
                command.append('dns_entries')
            subprocess.run(' '.join(command), shell=True, check=True)
        except subprocess.CalledProcessError as e:
            print('ERROR: Could not compress bootstrap archive.')
            sys.exit(1)

    print('')
    print('To update the admin node, do:')
    print('\t [sudo] tinc-sync/client -n %s --bootstrap %s/%s.tar.bz2' % (cfg.network_name, cfg.output_path, cfg.admin_node))


except AssertionError as e:
    print('ERROR:', e)
    sys.exit(1)

except PermissionError as e:
    print(e)
    sys.exit(1)

except KeyboardInterrupt:
    sys.exit(1)

except Exception as e:
    print('Caught some unhandled exception. YOU SHOULD TELL THE MAINTAINER THAT SOMETHING WAS UNHANDLED AND NEEDS LOOKING AT')
    print('Details:')
    print(e)
    traceback.print_exc()
    sys.exit(1)
